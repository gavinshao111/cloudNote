瀑布模型： 周期：制定计划、需求分析、软件设计、程序编写、软件测试和运行维护


数据库
索引：加快检索速度，但是增删改的时候需要维护成本。 索引就是通过事先排好序，从而在查找时可以应用二分查找等高效率的算法。
CREATE INDEX index_name
ON table_name (column_name)

存储过程：
一、存储过程与函数的区别：

　　1.一般来说，存储过程实现的功能要复杂一点，而函数的实现的功能针对性比较强。

　　2.对于存储过程来说可以返回参数(output)，而函数只能返回值或者表对象。

　　3.存储过程一般是作为一个独立的部分来执行，而函数可以作为查询语句的一个部分来调用，由于函数可以返回一个表对象，因此它可以在查询语句中位于FROM关键字的后面。

二、存储过程的优点：

　　1.执行速度更快 – 在数据库中保存的存储过程语句都是编译过的

　　2.允许模块化程序设计 – 类似方法的复用

　　3.提高系统安全性 – 防止SQL注入

　　4.减少网络流通量 – 只要传输存储过程的名称
例子：
-------------创建名为usp_StudentByGenderAge的存储过程----------------

create proc usp_StudentByGenderAge

　　@gender nvarchar(10) [='男'],

　　@age int [=30]

　　as

　　select * from MyStudent where FGender=@gender and FAge=@age
-------------执行上面的存储过程----------------

exec usp_StudentByGenderAge '女',50

数据库事务特性：
原子性：
一致性：拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000
分离性：隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。
持久性：一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的

二叉树：
结构：
struct BinaryTreeNode
{
    int m_nValue;
    BinaryTreeNode* m_pLeft;
    BinaryTreeNode* m_pRight;
};

求节点个数
int GetNodeNum(BinaryTreeNode * pRoot)  
{  
    if(pRoot == NULL) // 递归出口  
        return 0;  
    return GetNodeNum(pRoot->m_pLeft) + GetNodeNum(pRoot->m_pRight) + 1;  
}

求深度
int GetDepth(BinaryTreeNode * pRoot)  
{  
    if(pRoot == NULL) // 递归出口  
        return 0;  
    int depthLeft = GetDepth(pRoot->m_pLeft);  
    int depthRight = GetDepth(pRoot->m_pRight);  
    return depthLeft > depthRight ? (depthLeft + 1) : (depthRight + 1);   
}

前序遍历
void PreOrderTraverse(BinaryTreeNode * pRoot)  
{  
    if(pRoot == NULL)  
        return;  
    cout << pRoot->m_nValue << endl; // 访问根节点 
    PreOrderTraverse(pRoot->m_pLeft); // 前序遍历左子树  
    PreOrderTraverse(pRoot->m_pRight); // 前序遍历右子树  
}
中序就是先遍历左子树，再打印根节点，再访问右子树
后序就是先遍历左子树，再访问右子树，再打印根节点

单例模式：
懒汉模式：用锁来保证线程安全，但是会影响性能。
class Singleton
{
private:
    static Singleton* m_instance;
    Singleton(){}
public:
    static Singleton* getInstance();
};

Singleton* Singleton::getInstance()
{
    if(NULL == m_instance)
    {
        Lock();//借用其它类来实现，如boost
        if(NULL == m_instance)
        {
            m_instance = new Singleton;
        }
        UnLock();
    }
    return m_instance;
}
饿汉模式：全局定义对象指针，保证只执行一遍
class A {
    A() : m_data(0) {};
    int m_data;
    static const A* m_instance;
public:
    static const A* getInstance() {
        return m_instance;
    }
    void print() const {cout << m_data << endl;}
};

const A* A::m_instance = new A;